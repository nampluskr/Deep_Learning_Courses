## OOP

### Q1. 객체지향의 기본 개념은 무엇인가?

- 객체를 중심으로 소프트웨어를 설계하고 구현하는 프로그래밍 패러다임 (4가지 원칙)
- **Abstraction**
  - 객체의 핵심적인 속성과 동작만을 정의하고, 불필요한 세부 사항을 숨기는 원칙
  - 사용자는 필요한 정보만 활용하고, 내부 구현 방식에 대한 복잡성을 신경 쓰지 않아도 된다.
- **Encapsulation**
  - 객체의 데이터와 동작을 하나의 단위로 묶고, 외부에서 직접 접근하지 못하도록 제한하는 원칙
  - 데이터 무결성을 유지하고, 객체 간 결합도를 낮춰 안정성과 보안성을 향상시킨다.
- **Inheritance**: 
  - 부모 클래스의 속성과 동작을 자식 클래스가 재사용할 수 있도록 하는 원칙
  - 코드를 재사용하고, 계층 구조를 활용하여 확장성 있는 설계를 할 수 있다.
- **Polymorphism**
  - 같은 인터페이스를 공유하는 객체들이 서로 다른 방식으로 동작할 수 있도록 하는 원칙
  - 객체의 유형에 따라 동일한 요청이 다르게 실행되며, 유연하고 확장성 있는 설계를 가능하게 한다.

### Q2. 다형성(Polymorphism)은 프로그래밍 언어에서 어떻게 구현되는가?

- 다형성은 객체가 같은 인터페이스를 공유하지만, 구체적인 동작은 객체의 유형에 따라 다르게 실행될 수 있도록 하는 원칙
- **컴파일 시간 다형성 (Compile-time Polymorphism)** - **메서드 오버로딩(Method Overloading)**
  - 컴파일 시점에서 어떤 메서드를 실행할지 결정되는 방식
  - 같은 이름의 메서드를 여러 개 정의하되, 매개변수의 개수나 타입이 다르게 설정됨으로써 구분
- **런타임 다형성 (Runtime Polymorphism)** - **메서드 오버라이딩(Method Overriding)**
  - 프로그램이 실행되는 동안 어떤 메서드를 실행할지 결정되는 방식
  - 상속을 통해 자식 클래스가 부모 클래스의 메서드를 재정의(Override)하여 다르게 동작

### Q3. 정보 은닉(Information Hiding)의 개념을 설명하시오.

- 객체의 내부 구현을 감추고, 외부에서는 필수적인 기능만 접근할 수 있도록 하는 원칙
- 캡슐화(Encapsulation)의 핵심 요소
- 클래스 내부의 데이터를 직접 접근할 수 없도록 하고, 제한된 메서드를 통해서만 접근할 수 있도록 설계
- 외부에서는 제공된 메서드를 통해서만 데이터를 수정하거나 조회할 수 있으며, 객체의 데이터 처리 방식을 일관되게 유지
- 클래스 내부의 동작 방식이 변경되더라도 외부 코드에 미치는 영향을 최소화할 수 있다.
- private, protected, public 등의 접근 제한자를 활용하여 객체 내부의 변수와 메서드에 대한 접근을 제어

---

## SOLID

### Q1. SOLID 원칙의 목적은 무엇인가?

- 객체지향 소프트웨어 설계의 5가지 핵심 원칙
- 유지보수성과 확장성을 극대화하기 위한 소프트웨어 설계 원칙
- 코드의 가독성이 높아지고, 변경이 용이하며, 결합도를 낮추고 응집도를 높이는 효과

### Q2. 단일 책임 원칙(SRP)의 핵심 개념은 무엇인가?

- 하나의 모듈은 하나의 책임만 가져야 한다.
- 하나의 모듈을 정의할 때 그 모듈이 여러 책임을 가지고 있다면, 그 모듈은 여러 가지 이유로 변경될 가능성
- 모듈이 하나의 책임만 담당하고 있다면, 그 모듈이 변경될 가능성은 한 가지 책임이 변경되는 경우에만 발생

### Q3. 개방-폐쇄 원칙(OCP)의 핵심 개념은 무엇인가?

- 모듈은 확장에는 열려 있어야 하고 수정에는 닫혀 있어야 한다.
- 새로운 기능을 추가하거나 변경을 수행할 때, 모듈을 확장을 통해 그 변경을 반영하는 것은 좋지만, 기존에 있는 코드를 수정하는 것은 피해야 한다.
- [사례]
  - PaymentStrategy 인터페이스: CreditCardPayment, PayPalPayment
  - 새로운 결제 방법이 추가되어야 할 때, 기존의 코드는 변경할 필요가 없이 새로운 결제 방법을 수행 가능

### Q4. 리스코프 치환 원칙(LSP)의 핵심 개념은 무엇인가?

- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
- 부모 클래스로부터 자식 클래스를 정의할 때, 항상 오버라이드 시 기존 상위 클래스의 의도를 변경하지 않는 방식으로 오버라이드해야 한다.
- [사례]
  - Rectangle: setWidth(너비만 수정), setHeight, getWidth, getHeightSquare 
  - Square: setWidth(너비뿐만 아니라 높이까지 수정)와 setHeight 메소드를 오버라이드

### Q5. 인터페이스 분리 원칙(ISP)의 핵심 개념은 무엇인가?

- 클라이언트가 자신이 사용하지 않는 메소드에 의존하면 안 된다.
- 인터페이스를 작고 클라이언트에 특화된 여러 인터페이스로 분할하는 것을 권장한다.
- [사례] 여러 클라이언트들이 있고 모든 클라이언트가 하나의 큰 인터페이스에 의존한다고 가정
  - 클라이언트1은 operation1과 operation2만 이용
  - 클라이언트2는 operation3과 operation4만 이용
  - 클라이언트가 의존하는 오퍼레이션들만 포함하도록 인터페이스를 분리

### Q6. 의존성 역전 원칙(DIP)의 핵심 개념은 무엇인가?

- 고수준 모듈이 저수준 모듈에 의존하지 않도록 하고, 둘 다 추상화에 의존하도록 해야 한다.
- DIP의 목적은 저수준 모듈의 변경이 고수준 모듈에 영향을 미치지 않도록 하는 것
- [사례]
  - Copy 모듈은 ReadKeyboard나 WritePrinter와 같은 구체적인 저수준 모듈을 직접 의존하는 대신
  - Reader와 Writer라는 추상 인터페이스를 통해 알고리즘을 정의

### Q. 응집도(Cohesion)란 무엇이며, 함수, 클래스, 패키지, 컴포넌트 수준에서 어떻게 측정할 수 있는가?

- 모듈(함수, 클래스, 패키지, 컴포넌트 등)이 하나의 책임 또는 목적에 집중하는 정도를 의미
- 함수 수준: 하나의 함수가 단일한 작업만 수행하면 응집도가 높다.
- 클래스 수준: 클래스 내부 메서드들이 같은 데이터(속성)를 주로 사용하면 응집도가 높다.
- 패키지 수준: 같은 패키지 내 클래스들이 같은 도메인 기능을 수행하면 응집도가 높다.
- 컴포넌트 수준: 특정 비즈니스 로직을 수행하는 컴포넌트는 응집도가 높다.

### Q. 결합도(Coupling)란 무엇이며, 함수, 클래스, 패키지, 컴포넌트 수준에서 어떻게 측정할 수 있는가?

- 모듈 간의 의존성 정도를 나타내며, 낮을수록 유지보수성과 확장성이 높은 구조
- 함수 수준: 함수가 다른 함수의 내부 구현에 의존하면 결합도가 높다.
- 클래스 수준: 한 클래스가 다른 클래스의 세부 구현을 직접 참조하면 결합도가 높다.
- 패키지 수준: 서로 다른 패키지 간 직접적인 참조가 많으면 결합도가 높다.
- 컴포넌트 수준: 한 컴포넌트가 다른 컴포넌트에 강하게 의존하면 결합도가 높다.

---

## UML

### 1. 구조적 다이어그램 (Structural Diagrams)

- 시스템의 정적인 구조를 표현하며, 클래스, 객체, 패키지, 컴포넌트 간의 관계를 나타낸다.
- **Class Diagram**: 클래스 간의 관계(상속, 연관, 조합, 의존성 등)를 나타내며, 객체지향 설계를 표현하는 가장 중요한 다이어그램이다.
- **Object Diagram**: 특정 시점에서의 객체와 그 관계를 나타내며, 클래스 다이어그램의 인스턴스 표현이라고 볼 수 있다.
- **Component Diagram**: 시스템을 구성하는 모듈이나 컴포넌트 간의 의존 관계를 표현한다.
- **Deployment Diagram**: 하드웨어 노드와 소프트웨어 요소의 배포 관계를 나타내며, 시스템의 물리적 배포 구조를 모델링한다.
- **Package Diagram**: 여러 클래스나 모듈을 논리적으로 그룹화하여 패키지 간의 관계를 표현한다.

### 2. 행위 다이어그램 (Behavioral Diagrams)

- 시스템이 수행하는 기능과 동작을 표현하며, 객체 간의 상호작용과 시스템의 동적 흐름을 나타낸다.
- **Use Case Diagram**: 사용자(액터)와 시스템 간의 상호작용을 모델링하며, 시스템의 기능을 추상적으로 표현한다.
- **Sequence Diagram**: 객체 간의 메시지 교환 순서를 시간 흐름에 따라 표현하며, 상호작용을 구체적으로 보여준다.
- **Communication Diagram**: 객체 간의 메시지 교환 관계를 네트워크 형태로 나타내며, 객체 간의 협력 관계를 강조한다.
- **State Diagram**: 객체의 상태 변화와 상태 전이를 표현하며, 특정 객체의 동작을 모델링할 때 유용하다.
- **Activity Diagram**: 시스템 내부의 프로세스 흐름을 표현하며, 비즈니스 로직이나 알고리즘의 흐름을 시각화하는 데 사용된다.

---

## Architecture Drivers

- 기능 요구사항 (FR, UC Scenario): 시스템이 수행해야 하는 주요 기능을 정의하며, 사용자 관점에서 필수적인 기능들을 명확하게 기술한다.
- 품질 요구사항 (QA Scenario): 시스템의 비기능적 특성을 정의하는 요소로, 아키텍처 설계에 가장 큰 영향을 미친다.
- 제약 사항(AC): 시스템이 따라야 하는 기술적 제한 사항으로, 사용할 기술 스택, 하드웨어 및 소프트웨어 플랫폼, 기존 시스템과의 통합 등이 포함된다.

## Architecture Views

- Component and Conector View
  - 실행 시간에 인지될 수 있는 시스템 컴포넌트(프로세스, 스레드, 데이터 저장소 등)가 무엇이고 이들이 어떻게 상호작용하는지를 커넥터로 표현
  - 런타임에 나타나는 대상들로 구조적으로 클라이언트, 서버, 프로세스, 객체 등의 순으로 구성될 수 있지만
  - 상위 수준의 구조 설계에서는 객체 레벨까지 표현하지 않고, 필요한 경우 스레드 수준까지만 표현하는 것이 적합
- Deployment View
  - 컴포넌트와 커넥터가 컴퓨팅 플랫폼의 하드웨어에 어떻게 대응되는지를 나타내는 모델
  - 컴포넌트는 소프트웨어 엘리먼트와 환경 엘리먼트로 구분
  - 커넥터는 이들 엘리먼트 간의 커뮤니케이션 링크로 표현
  - 엘리먼트들은 노드로 표현

## Architecture Styles



## Architecture Tatics

- Performance: 시간과 관련된 품질 속성을 향상시키기 위한 방법들
- Availability: 시스템에 장애가 발생하더라도 서비스가 지속될 수 있도록 하는 방법들
- Security: 공격을 감지하고, 저항하며, 대응하고 복구하는 방법들
- Usability: 사용자 주도적 작업 지원과 시스템 주도적 작업 지원으로 나뉨
- Interoperability: 시스템 간 정보 교환 요청을 올바르게 처리하는 방법들
- Modifiability: 모듈 수를 작게 유지하고, 각 모듈이 하나의 책임만 담당하도록 하며, 모듈 간의 의존성을 줄여 결합도를 낮추는 것 (SRP)
- Testability: 시스템 상태를 제어하고 관측 / 복잡성을 제한하는 것

---

## Design Patterns

- **생성 패턴**: 객체의 생성 과정을 캡슐화하여 객체 생성과 관련된 복잡성을 줄이는 패턴
  - Singleton: 특정 클래스의 인스턴스를 하나만 생성하도록 제한
  - Factory Method: 객체 생성을 서브클래스에서 담당하도록 위임
  - Abstract Factory: 관련 객체 군을 생성할 때 일관성을 유지
  - 나머지 (1줄 요약)

- **구조 패턴**: 클래스와 객체의 구조를 정의하여 유지보수성과 확장성을 높이는 패턴
  - Adapter: 서로 다른 인터페이스를 가진 객체들을 호환되도록 변환
  - Decorator: 기존 객체의 기능을 변경하지 않고 새로운 기능을 추가
  - Facade: 복잡한 시스템 내부 구조를 감추고 단순한 인터페이스를 제공
  - 나머지 (1줄 요약)

- **행위 패턴**: 객체 간의 상호작용과 책임을 정의하여 효율적인 데이터 흐름과 역할 분리를 지원
  - Strategy: 실행할 알고리즘을 동적으로 변경할 수 있도록 인터페이스를 제공
  - Observer: 객체 상태 변경을 자동으로 다른 객체에 전파
  - Command: 요청을 객체로 캡슐화하여 실행 취소(Undo) 기능을 지원
  - 나머지 (1줄 요약)

### Q. 전략 패턴과 옵저버 패턴의 차이점은 무엇인가?

- 전략 패턴은 행위를 동적으로 교체하는 데 사용되며, 옵저버 패턴은 상태 변화를 관리하는 데 사용된다.
- 전략 패턴은 객체 간 결합도를 낮추는 데 초점을 맞추고, 옵저버 패턴은 이벤트 기반 시스템에서 객체 간 의존성을 효과적으로 관리한다.

### Q. 전략 패턴과 상태 패턴의 차이점은 무엇인가?

- 전략 패턴은 클라이언트가 원하는 전략(알고리즘)을 직접 선택하여 적용.
- 상태 패턴은 객체의 상태에 따라 동작이 자동으로 변경됨.
- 전략 패턴은 동일한 작업을 다양한 방식으로 수행할 때 사용되며, 상태 패턴은 객체의 상태에 따라 다른 동작을 수행할 때 사용된다.

### Q. 전략 패턴과 템플릿 메서드 패턴의 차이점은 무엇인가?

- 전략 패턴은 알고리즘을 독립적인 클래스로 분리하고, 클라이언트가 원하는 전략을 선택.
- 템플릿 메서드 패턴은 알고리즘의 기본 구조를 고정하고, 일부 단계를 서브클래스에서 구현하도록 유도.
- 전략 패턴은 실행할 알고리즘을 동적으로 선택하는 데 중점을 두며, 템플릿 메서드 패턴은 알고리즘의 흐름을 유지하면서 세부 구현을 다르게 정의하는 데 초점을 둔다.

### Q. 전략 패턴과 커맨드 패턴의 차이점은 무엇인가?

- 전략 패턴은 클라이언트가 실행할 알고리즘을 직접 선택하는 반면, 커맨드 패턴은 요청을 캡슐화하여 큐에 저장하거나 실행 취소 등의 기능을 제공.
- 전략 패턴은 알고리즘을 동적으로 교체하는 데 초점이 맞춰져 있으며, 커맨드 패턴은 실행 요청을 나중에 실행하거나 취소할 수 있도록 캡슐화하는 데 초점이 맞춰져 있다.
- 전략 패턴은 클라이언트가 실행할 전략을 직접 선택하는 반면, 커맨드 패턴은 실행 명령을 객체로 캡슐화하여 독립적으로 실행할 수 있도록 한다.

### Q. 파사드 패턴과 중재자 패턴의 차이점은 무엇인가?

- 파사드 패턴은 클라이언트가 복잡한 시스템을 쉽게 사용할 수 있도록 단순한 인터페이스를 제공.
- 중재자 패턴은 객체 간의 직접적인 상호작용을 없애고 중앙에서 조정 역할을 수행.

### Q. 파사드 패턴과 복합체 패턴의 차이점은 무엇인가?

- 파사드 패턴은 복잡한 시스템을 단순한 인터페이스로 감싸는 역할을 하며, 클라이언트가 쉽게 사용할 수 있도록 한다.
- 복합체 패턴은 개별 객체와 복합 객체를 동일한 방식으로 다룰 수 있도록 계층 구조를 형성한다.
- 파사드 패턴은 인터페이스 단순화에 집중하고, 복합체 패턴은 계층적 관계를 효과적으로 관리하는 데 중점을 둔다.

### Q. 템플릿 메서드 패턴과 팩토리 메서드 패턴의 차이점은 무엇인가?

- 템플릿 메서드 패턴은 알고리즘의 실행 흐름을 정의하고, 일부 단계를 서브클래스에서 재정의할 수 있도록 한다.
- 팩토리 메서드 패턴은 객체 생성을 서브클래스에서 결정할 수 있도록 하여, 객체 생성 로직을 유연하게 확장할 수 있도록 한다.
- 템플릿 메서드는 알고리즘의 실행 순서를 제어하고, 팩토리 메서드는 객체 생성을 제어하는 역할을 한다.

### Q. 옵저버 패턴과 퍼블리셔-구독자 패턴의 차이점은 무엇인가?

- 옵저버 패턴은 주제(Subject)와 옵저버 간의 직접적인 관계를 유지하며, 주제가 변경될 때 옵저버들에게 자동으로 상태가 전달됨.
- 퍼블리셔-구독자 패턴은 메시지 브로커를 통해 이벤트를 전달하며, 퍼블리셔와 구독자가 직접적으로 연결되지 않음.
- 옵저버 패턴은 작은 규모의 이벤트 처리에 적합하며, 퍼블리셔-구독자 패턴은 대규모 분산 시스템에서 확장성이 뛰어남.
