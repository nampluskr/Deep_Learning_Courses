### 변형된 다익스트라

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
#include <climits>

using namespace std;

// 도로 정보 저장을 위한 구조체
struct Road {
    int id;
    int start;
    int end;
    int cost;
    bool isActive;  // 도로가 활성화되어 있는지 여부
};

// 최대 N, K 값 정의
#define MAX_N 300
#define MAX_K 1000 + 700  // 초기 K + 최대 add 횟수

// 전역 변수
int N;  // 도시 수
Road roads[MAX_K];  // 도로 정보 배열
int roadCnt;  // 현재 도로 수
unordered_map<int, int> roadMap;  // mId -> roads 배열 인덱스 매핑

// 인접 리스트 (도시 -> 연결된 도로 정보)
struct Edge {
    int to;    // 도착 도시
    int cost;  // 도로 비용
};
vector<Edge> graph[MAX_N];

// 경로 상태를 나타내는 구조체
struct PathState {
    int diff;    // 최대-최소 비용 차이
    int city;    // 현재 도시
    int maxCost; // 현재까지 최대 비용
    int minCost; // 현재까지 최소 비용

    // 우선순위 큐에서 사용할 비교 연산자
    bool operator>(const PathState& other) const {
        return diff > other.diff;
    }
};

void add(int mId, int sCity, int eCity, int mCost);

// 초기화 함수
void init(int _N, int K, int mId[], int sCity[], int eCity[], int mCost[]) {
    // 전역 변수 초기화
    N = _N;
    roadCnt = 0;
    roadMap.clear();

    // 그래프 초기화
    for (int i = 0; i < MAX_N; i++) {
        graph[i].clear();
    }

    // 도로 정보 추가
    for (int i = 0; i < K; i++) {
        add(mId[i], sCity[i], eCity[i], mCost[i]);
    }
}

// 도로 추가 함수
void add(int mId, int sCity, int eCity, int mCost) {
    // 도로 정보 저장
    roads[roadCnt] = { mId, sCity, eCity, mCost, true };

    // 매핑 정보 업데이트
    roadMap[mId] = roadCnt;

    // 그래프에 도로 추가
    graph[sCity].push_back({ eCity, mCost });

    // 도로 카운트 증가
    roadCnt++;
}

// 도로 제거 함수
void remove(int mId) {
    // 제거할 도로의 인덱스 찾기
    int idx = roadMap[mId];

    // 도로 비활성화
    roads[idx].isActive = false;

    // 그래프 재구성
    for (int i = 0; i < N; i++) {
        graph[i].clear();
    }

    // 활성화된 도로만 그래프에 다시 추가
    for (int i = 0; i < roadCnt; i++) {
        if (roads[i].isActive) {
            graph[roads[i].start].push_back({ roads[i].end, roads[i].cost });
        }
    }
}

// 최소 차이 경로 찾기
int cost(int sCity, int eCity) {
    // 도착 불가능한 경우 빠르게 체크
    if (sCity == eCity) {
        return 0;  // 같은 도시면 차이는 0
    }

    // 우선순위 큐 사용: 구조체로 경로 상태 관리
    priority_queue<PathState, vector<PathState>, greater<PathState>> pq;

    // 방문 배열: 각 도시별 최소 차이값 저장 (3차원)
    vector<vector<vector<int>>> minDiff(N, vector<vector<int>>(501, vector<int>(501, INT_MAX)));

    // 시작점에서 직접 갈 수 있는 도시들을 큐에 추가
    for (const auto& edge : graph[sCity]) {
        int nextCity = edge.to;
        int cost = edge.cost;
        pq.push({ 0, nextCity, cost, cost });
        minDiff[nextCity][cost][cost] = 0;
    }

    while (!pq.empty()) {
        PathState current = pq.top();
        pq.pop();

        int diff = current.diff;
        int city = current.city;
        int maxCost = current.maxCost;
        int minCost = current.minCost;

        // 이미 더 좋은 상태를 찾은 경우 무시
        if (diff > minDiff[city][maxCost][minCost]) continue;

        // 도착 도시에 도달한 경우
        if (city == eCity) {
            return diff;
        }

        // 인접 도시 탐색
        for (const auto& edge : graph[city]) {
            int nextCity = edge.to;
            int roadCost = edge.cost;

            int newMaxCost = max(maxCost, roadCost);
            int newMinCost = min(minCost, roadCost);
            int newDiff = newMaxCost - newMinCost;

            // 더 좋은 상태를 찾은 경우 업데이트
            if (newDiff < minDiff[nextCity][newMaxCost][newMinCost]) {
                minDiff[nextCity][newMaxCost][newMinCost] = newDiff;
                pq.push({ newDiff, nextCity, newMaxCost, newMinCost });
            }
        }
    }

    // 도착 도시에 도달할 수 없는 경우
    return -1;
}
```
