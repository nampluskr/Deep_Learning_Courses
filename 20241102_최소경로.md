### 변형된 다익스트라

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAX_N = 1000;	// 노드(도시)의 최대 개수
const int MAX_K = 10000;	// 간선(도로)의 최대 개수
const int INF = 0x3f3f3f3f;

struct Edge {
	int to, mCost;
};
vector<Edge> graph[MAX_N];

enum State { ADDED, REMOVED };
struct Road {
	int sCity, eCity, mCost;
	State state;
};
Road roads[MAX_K];
int roadCnt;
unordered_map<int, int> roadMap;

// 경로 상태를 나타내는 구조체
struct PathState {
	int diff;    // 최대-최소 비용 차이
	int city;    // 현재 도시
	int maxCost; // 현재까지 최대 비용
	int minCost; // 현재까지 최소 비용

	// 우선순위 큐에서 사용할 비교 연산자
	bool operator>(const PathState& other) const {
		return diff > other.diff;
	}
};

int N;
int K;

void add(int mId, int sCity, int eCity, int mCost);

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[]) {
	::N = N;
	::K = K;

	roadMap.clear();
	roadCnt = 0;
	for (int i = 0; i < N; i++) graph[i].clear();
	for (int i = 0; i < K; i++) add(mId[i], sCity[i], eCity[i], mCost[i]);
}

void add(int mId, int sCity, int eCity, int mCost) {
	roadMap[mId] = roadCnt;
	roads[roadCnt] = { sCity, eCity, mCost, ADDED };
	graph[sCity].push_back({ eCity, mCost });
	roadCnt++;
}

void remove(int mId) {
	int rIdx = roadMap[mId];
	roads[rIdx].state = REMOVED;

	// 그래프 재구성
	for (int i = 0; i < N; i++) {
		graph[i].clear();
	}

	for (int i = 0; i < roadCnt; i++) {
		if (roads[i].state == ADDED) {
			graph[roads[i].sCity].push_back({ roads[i].eCity, roads[i].mCost });
		}
	}
}

int cost(int sCity, int eCity) {
	// 우선순위 큐 사용: 구조체로 경로 상태 관리
	priority_queue<PathState, vector<PathState>, greater<PathState>> pq;

	// 방문 배열: 각 도시별 최소 차이값 및 상태 저장 (2차원)
	// visited[city][state] = true 형태로 저장하기에는 state 범위가 너무 크므로
	// 각 도시별로 (maxCost, minCost) 쌍에 대한 최소 차이값을 저장
	vector<vector<vector<int>>> minDiff(N, vector<vector<int>>(501, vector<int>(501, INF)));

	// 시작점은 아직 도로를 지나지 않았으므로 특별 처리
	// 첫 도로를 지났을 때의 상태를 큐에 넣음
	for (const auto& edge : graph[sCity]) {
		int nextCity = edge.to;
		int cost = edge.mCost;
		pq.push({ 0, nextCity, cost, cost });
		minDiff[nextCity][cost][cost] = 0;
	}

	while (!pq.empty()) {
		PathState current = pq.top();
		pq.pop();

		int diff = current.diff;
		int city = current.city;
		int maxCost = current.maxCost;
		int minCost = current.minCost;

		// 이미 더 좋은 상태를 찾은 경우 무시
		if (diff > minDiff[city][maxCost][minCost]) continue;

		// 도착 도시에 도달한 경우
		if (city == eCity) {
			return diff;
		}

		// 인접 도시 탐색
		for (const auto& edge : graph[city]) {
			int nextCity = edge.to;
			int roadCost = edge.mCost;

			int newMaxCost = max(maxCost, roadCost);
			int newMinCost = min(minCost, roadCost);
			int newDiff = newMaxCost - newMinCost;

			// 더 좋은 상태를 찾은 경우 업데이트
			if (newDiff < minDiff[nextCity][newMaxCost][newMinCost]) {
				minDiff[nextCity][newMaxCost][newMinCost] = newDiff;
				pq.push({ newDiff, nextCity, newMaxCost, newMinCost });
			}
		}
	}

	// 도착 도시에 도달할 수 없는 경우
	return -1;
}
```
